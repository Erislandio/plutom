(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "./util", "./expr", "./tables"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("./util"), require("./expr"), require("./tables"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.util, global.expr, global.tables);
    global.command = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports, _util, _expr, _tables) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.dropToSQL = dropToSQL;
  _exports.truncateToSQL = truncateToSQL;
  _exports.renameToSQL = renameToSQL;
  _exports.useToSQL = useToSQL;
  _exports.callToSQL = callToSQL;
  _exports.setVarToSQL = setVarToSQL;
  _exports.lockUnlockToSQL = lockUnlockToSQL;

  function dropToSQL(stmt) {
    const clauses = ['DROP TABLE', (0, _tables.tablesToSQL)(stmt.table)];
    return clauses.join(' ');
  }

  function truncateToSQL(stmt) {
    const clauses = ['TRUNCATE', stmt.keyword, (0, _tables.tablesToSQL)(stmt.table)];
    return clauses.filter(_util.hasVal).join(' ');
  }

  function renameToSQL(stmt) {
    const {
      type,
      table
    } = stmt;
    const clauses = [];
    const prefix = `${type && type.toUpperCase()} TABLE`;

    if (table) {
      for (const tables of table) {
        const renameInfo = tables.map(_tables.tableToSQL);
        clauses.push(renameInfo.join(' TO '));
      }
    }

    return `${prefix} ${clauses.join(', ')}`;
  }

  function useToSQL(stmt) {
    const {
      type,
      db
    } = stmt;
    const action = type && type.toUpperCase();
    const database = (0, _util.identifierToSql)(db);
    return `${action} ${database}`;
  }

  function callToSQL(stmt) {
    const type = 'CALL';
    const storeProcessCall = (0, _expr.exprToSQL)(stmt.expr);
    return `${type} ${storeProcessCall}`;
  }

  function setVarToSQL(stmt) {
    const {
      expr
    } = stmt;
    const action = 'SET';
    const val = (0, _expr.exprToSQL)(expr);
    return `${action} ${val}`;
  }

  function pgLock(stmt) {
    const {
      lock_mode: lockMode,
      nowait
    } = stmt;
    const lockInfo = [];

    if (lockMode) {
      const {
        mode
      } = lockMode;
      lockInfo.push(mode.toUpperCase());
    }

    if (nowait) lockInfo.push(nowait.toUpperCase());
    return lockInfo;
  }

  function lockUnlockToSQL(stmt) {
    const {
      type,
      keyword,
      tables
    } = stmt;
    const result = [type.toUpperCase(), (0, _util.toUpper)(keyword)];
    if (type.toUpperCase() === 'UNLOCK') return result.join(' ');
    const tableStmt = [];

    for (const tableInfo of tables) {
      const {
        table,
        lock_type: lockType
      } = tableInfo;
      const tableInfoTemp = [(0, _tables.tableToSQL)(table)];

      if (lockType) {
        const lockKeyList = ['prefix', 'type', 'suffix'];
        tableInfoTemp.push(lockKeyList.map(key => (0, _util.toUpper)(lockType[key])).filter(_util.hasVal).join(' '));
      }

      tableStmt.push(tableInfoTemp.join(' '));
    }

    result.push(tableStmt.join(', '), ...pgLock(stmt));
    return result.filter(_util.hasVal).join(' ');
  }
});